<?xml version="1.0" encoding="UTF-8"?>
<!--
 Licensed to the Apache Software Foundation (ASF) under one
 or more contributor license agreements.  See the NOTICE file
 distributed with this work for additional information
 regarding copyright ownership.  The ASF licenses this file
 to you under the Apache License, Version 2.0 (the
 "License"); you may not use this file except in compliance
 with the License.  You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing,
 software distributed under the License is distributed on an
 "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 KIND, either express or implied.  See the License for the
 specific language governing permissions and limitations
 under the License.    
-->
<document>
<properties>
<title>Guía del Usuario de Velocity</title>
<author email="jvanzyl@zenplex.com">Velocity Documentation Team</author>
<author email="jcastura@kw.igs.net">John Castura</author>
<author email="ju-moral@uniandes.edu.co">Juan Pablo Morales</author>
</properties>
<body>
    <section name="Tabla de Contenidos" href="TabladeContenidos">

<ol>
    <li><a href="#Acercadeestaguía">Acerca de esta guía</a></li>
    <li><a href="#¿QuéesVelocity?">¿Qué es Velocity?</a></li>
    <li><a href="#¿QuépuedehacerVelocitypormi?">¿Qué puede hacer Velocity por mi?</a>
    <ol>
        <li><a href="#ElEjemplodelatiendadeLodo">El Ejemplo de la tienda de
            Lodo</a></li>
    </ol>
</li>
<li><a href="#ElLenguajedePlantillasdeVelocity(VTL):UnaIntroducción">El Lenguaje de Plantillas de Velocity (VTL): Una Introducción</a></li>
<li><a href="#¡HolaMundoVelocity!">¡Hola Mundo Velocity!</a></li>
<li><a href="#Comentarios">Comentarios</a></li>
<li><a href="#Referencias">Referencias</a>
    <ol>
        <li><a href="#Variables">Variables</a></li>
        <li><a href="#Propiedades">Propiedades</a></li>
        <li><a href="#Métodos">Métodos</a></li>
    </ol>
</li>
<li><a href="#NotaciónFormaldeReferencias">Notación Formal de Referencias</a></li>
<li><a href="#NotaciónSileciosadeReferencias">Notación Sileciosa de Referencias</a></li>
<li><a href="#Literalmente">Literalmente</a>
    <ol>
        <li><a href="#Dinero">Dinero</a></li>
        <li><a href="#EscapandoReferenciasVTLVálidas">Escapando Referencias VTL Válidas</a></li>
    </ol>
</li>
<li><a href="#SustitucióndeMayúsculasyMinúsculas">Sustitución de Mayúsculas y Minúsculas</a></li>
<li><a href="#Directivas">Directivas</a>
    <ol>
        <li><a href="#Set">Set</a></li>
        <li><a href="#CadenasdeCaracteres">Cadenas de Caracteres</a></li>
        <li><a href="#SentenciasIf-Else">Sentencias If-Else</a>
            <ol>
                <li><a href="#OperadoresLógicosyRelacionales">Operadores Lógicos y Relacionales</a></li>
            </ol>
        </li>
        <li><a href="#CiclosForeach">Ciclos Foreach</a></li>
        <li><a href="#Include">Include</a></li>
        <li><a href="#Parse">Parse</a></li>
        <li><a href="#Stop">Stop</a></li>
        <li><a href="#Velocimacros">Velocimacros</a></li>
    </ol>
</li>
<li><a href="#EscapandoDirectivasVTL">Escapando Directivas VTL</a></li>
<li><a href="#VTL:AsuntosdeFormato">VTL: Asuntos de Formato</a></li>
<li><a href="#OtrasCaracterísticasyMiscelánea">Otras Características y Miscelánea</a>
    <ol>
        <li><a href="#Matemáticas">Matemáticas</a></li>
        <li><a href="#ElOperadordeRango">El Operador de Rango</a></li>
        <li><a href="#TemasAvanzados:Escapandoy!">Temas Avanzados: Escapando y !</a></li>
        <li><a href="#MisceláneadeVelocimacro">Miscelánea de Velocimacro</a></li>
        <li><a href="#ConcatenacióndeCadenas">Concatenación de Cadenas</a></li>
    </ol>
</li>
<li><a href="#Retroalimentación">Retroalimentación</a></li>
</ol>
</section>
<section name="Acerca de esta guía" href="Acercadeestaguía">

<p>
La Guía del usuario de Velocity busca ayudar a los diseñadores de páginas y a
los proveedores de contenido a sentirse a gusto con Velocity y con la sintáxis
de su simple pero poderoso lenguaje de script, el Lenguaje de Plantillas de
Velocity (VTL por sus siglas en inglés).  Muchos de los ejemplos de esta guía
muestran como usar Velocity para incluir contenidos dinámicos en sitios web,
pero todos los ejemplos de VTL son igualmente aplicables a otras páginas y
plantillas.
</p>

<p>Gracias por escoger Velocity!</p>
</section>
<section name="¿Qué es Velocity?" href="QuéesVelocity?">
<p>
Velocity es un motor de plantillas basado en Java. Le permite a los diseñadores
de páginas hacer referencia a métodos definidos dentro del código Java. Los
diseñadores Web pueden trabajar en paralelo con los programadores Java para
desarrollar sitios de acuerdo al modelo de Modelo-Vista-Controlador (MVC),
permitiendo que los diseñadores se concentren únicamente en crear un sitio bien
diseñado y que los programadores se encarguen solamente de escribir código de
primera calidad. Velocity separa el código Java de las páginas Web, haciendo el
sitio más mantenible a largo plazo y presentando una alternativa viable a <a
    href="http://java.sun.com/products/jsp/">Java Server Pages</a> (JSP) o <a
    href="http://www.php.net">PHP</a>.
</p>

<p>
Velocity se puede utilizar para crear páginas web, SQL, PostScript y cualquier
otro tipo de salida de plantillas. Se puede utilizar como una aplicación
independiente para generar código fuente y reportes, o como un componente
integrado en otros sistemas. Cuando este completo Velocity proveerá servicios
para el conjunto de aplicaciones web de <a
    href="http://jakarta.apache.org/turbine">Turbine</a>.  Velocity+Turbine
proveerá un servicio de plantillas que facilitará el desarrollo de aplicaciones
web de acuerdo a un verdadero modelo MVC.
</p>
</section>
<section name="¿Qué puede hacer Velocity por mi?" href="QuépuedehacerVelocitypormi?">
<subsection name="El Ejemplo de la tienda de Lodo" href="ElEjemplodelatiendadeLodo">
<p>
Suponga que usted es un diseñador para una tienda en línea que se especializa
en vender lodo a la que llamaremos "La Tienda de Lodo en línea". Los negocios
están muy bien. Sus clientes ordenan diferentes tipos y cantidades de
lodo.
Ellos ingresan en su sitio con su nombre de usuario y su clave secreta, lo que
les permite ver sus órdenes y pedir más lodo. En estos momentos el Lodo
Terracota, que es muy popular, esta en oferta. Una minoría de sus clientes
usualmente compra Lodo Rojo Brillante, que también esta en oferta, pero no es
tan popular y usualmente esta relegado al márgen de su página web. La
información sobre cada cliente esta dentro de su base de datos por lo que surge
la pregunta: ¿Por qué no usar Velocity para enfocar las ofertas especiales para
los clientes que están más interesados en ciertas clases de lodo?
</p>

<p>
Velocity hace fácil el personalizar las páginas para sus visitantes.  Como un
diseñador dentro de "El Cuarto de Lodo", usted quiere crear la página que sus
usuarios verán después de entrar a su sitio.
</p>

<p>
Usted se encuentra con los ingenieros de su compañía, y todos acuerdan que
<em>$cliente</em> contendrá la información pertienente al cliente que está
dentro de la página en un momento dado, que <em>$lodosEnOferta</em> contendrá
todos los tipos de lodo que están en oferta hoy en día.  Además, el objeto
<em>$flogger</em> contendrá métodos para ayudar con la promoción. Para la tarea
actual, solo se utilizarán estas tres referencias. Recuerde, usted no necesita
preocuparse por como los ingenieros de software extraen la información
necesaria de la base de datos; sólo tiene que saber que funciona. Esto le
permite a usted continuar con su trabajo a la vez que deja a los ingenieros
hacer el de ellos.
</p>

<p>Usted podría incluir el siguiente código VTL dentro de su página:</p>

<source>
<![CDATA[
<HTML>
<BODY>
Hello $cliente.Nombre!
<table>
#foreach( $lodo in $lodosEnOferta )
#if ( $cliente.haComprado($lodo) )
<tr>
<td>
$flogger.obtenerPromocion( $lodo )
</td>
</tr>
#end
#end
</table>
]]>
</source>

<p>
Los detalles exactos de la sentencia <i>foreach</i> serán descritos en
profundidad próximamente; lo que es importante es el impacto que este pequeño
script pueda tener en su sitio.  Cuando un cliente con una debilidad por el
Lodo Rojo Brillante ingrese, si el Lodo Rojo Brillante esta en oferta, eso
será lo que el cliente verá, de manera prominente. Si otro cliente, con una
historia larga de compras de Lodo Terracota ingresa, entonces para él la
noticia de un rebaja de Lodo Terracota estará en un lugar muy importante. La
flexibilidad de Velocity es enorme y sólo esta limitada por su creatividad.
</p>

<p>
En la  referencia de VTL están documentados muchos otros elementos de Velocity
que, colectivamente le dan el poder y la flexibilidad que usted necesita para
hacer de su sitio en la red una <em>presencia</em> en la red. A medida que
usted se familiarice con estos elementos usted comenzará a aprovechar el poder
de Velocity.
</p>
</subsection>
</section>
<section name="El Lenguaje de Plantillas de Velocity (VTL): Una Introducción" href="ElLenguajedePlantillasdeVelocity(VTL):UnaIntroducción">
  <p>
  El Lenguaje de Plantillas de Velocity (VTL) fue creado para prover la
  manera mas fácil, simple y limpia de incorporar contenido dinámico
  dentro de una página web. Incluso un desarrollador de páginas web con
  poca y ninguna experiencia puede rápidamente ser capaz de utilizar VTL
  para incluir contenido dinámico en un sitio web.
 </p>

 <p>
    VTL usa <em>referencias</em> para incluir contenido dinámico dentro
    de un sitio web. Una variable es un tipo de referencia que puede
    referirse a algo definido dentro del código Java o obtener su valor
    de un <em>enunciado</em> VTL en la página misma. A continuación hay
    un ejemplo de un enunciado VTL que se puede incluir en un documento
    HTML:
 </p>

<source><![CDATA[
#set( $a = "Velocity" )
]]></source>

  <p>
    Este enunciado VTL, como todos los enunciados VTL comienza con el
    caracter <em>#</em> y contiene una directiva: <em>set</em>. Cuando
    un visitante solicita su página, el Motor de Plantillas de Velocity
    buscará dentro del contenido de su página y encontrará todos los
    símbolos <em>#</em>, para luego determinar cuáles marcan el comienzo
    de enunciados VTL y cuáles no tienen nada que ver con VTL.
 </p>

 <p>
 El caracter <em>#</em> viene seguido por una directiva <em>set</em>.
 La directiva <em>set</em> utiliza una expresión (encerrada entre
 paréntesis) -- una ecuación que asigna un <em>valor</em> a una
 <em>variable</em>.
 La variable se encuentra en el lado derecho y el valor está en el lado
 izquierdo; los dos se encuentran separados por un signo igual
 (<em>=</em>).
 </p>

 <p>
 En el ejemplo en la parte superior, la variable es <em>$a</em> y el
 valor es <em>Velocity</em>. Esta variable, al igual que todas las
 referencias, comienza con el caracter <em>$</em>. Los valores siempre
 se encuentran ente comillas; con Velocity no hay confusión acerca de
 los tipos de datos, ya que solamente cadenas (información basada en
 texto) pueden ser pasados a las variables.
 </p>

 <p>
 La siguiente regla puede ser útil para entender mejor como funciona
 Velocity: <strong>Las Referencias comienzan con <em>$</em> y se
     utilizan para obtener algo. Las directivas comienzan con <em>#</em>
     y se utilizan para hacer algo</strong>
 </p>

 <p>
 En el ejemplo anterior <em>#set</em> se utilizó para asignarle un valor
 a una variable. La variable, <em>$a</em>, puede utilizarse dentro de la
 plantilla para escribir la palabara "Velocity".
 </p>

</section>

<section name="¡Hola Mundo Velocity!" href="HolaMundoVelocity!">

  <p>
    Una vez un valor ha sido asignado a una variable, usted puede
    referenciar la variable en cualquier lugar dentro del documento
    HTML. En el ejemplo siguiente, un valor es asignado a la variable
    <em>$foo</em>, que luego es referenciada.
 </p>

<source><![CDATA[
<html>
<body>
#set( $foo = "Velocity" )
¡Hola Mundo $foo!
</body>
<html>
]]></source>

 <p>
 El resultado es una página web que imprime "¡Hola Mundo Velocity!"
 </p>

 <p>
 Para hacer los enunciados con directivas VTL más legibles, nosotros le
 recomendamos comenzar cada enunciado VTL en una nueva línea, aunque
 usted no esta obligado a hacerlo así. La directiva <em>set</em> ser
 verá con mayor detalle más adelante.
 </p>

</section>

<section name="Comentarios" href="Comentarios">

<p>
Los comentarios es posible incluir texto que no aparecerá como parte de
la salida del motor de plantillas. Los comentarios sirven para recordar
e indicar a otros que es lo que están haciendo los enunciados VTL, o
para cualquier otro propósito que usted considere útil. A continuación
hay un ejemplo de un comentario de VTL.
</p>

<source><![CDATA[
## Este es un comentario de una sola línea
]]></source>

<p>
    Un comentario de una sola línea comienza con <em>##</em> y termina
    al final de la línea. Si usted desea escribir varias líneas de
    comentario no es necesario tener numerosos comentarios de una sóla
    línea. Los comentarios de varias líneas, que comienzan con
    <em>#*</em> y terminan con <em>*#</em> le permiten manejar
    fácilmente esta situación.
 </p>

 <source><![CDATA[
 Este es un texto que esta fuera de un comentario de múltiples líneas.
 Los visitantes de su página lo pueden ver.

#*
 He aquí un comentario de varias líneas. Los visitantes
 de su sitio no verán esto, ya que el Motor de Plantillas
 de Velocity lo ignorará
*#

Aquí hay texto fuera del comentario, este si es visible.
]]></source>

 <p>
    A continuación hay algunos ejemplos para aclarar como funcionan
    los comentarios de una y varias líneas:
 </p>

 <source><![CDATA[
Este texto es visible. ## Este no lo es
Este texto es visible.
Este texto es visible. #* Este texto, como parte de un comentario de
varias líneas, no es visible. Este texto no es visible; tambiés es parte
del comentario. Este texto aún no es visible. *# Este texto esta fuera
del comentario, por lo que es visible.
## Este texto no es visible.
]]></source>

<p>
    Existe un tercer tipo de comentario, el bloque de comentario VTL,
    que puede ser utilizado para almacenar datos como el autor y la
    información de versiones:
</p>

<source><![CDATA[
#**
Este es un bloque de comentario VTL y
puede utilizarse para almacenar datos
como el nombre del autor y la
información de versiones:
@author
@version 5
*#
]]></source>

</section>

<section name="Referencias" href="Referencias">

<p>
    Existen tres tipos de referencias en VTL: variables, propiedades y
    métodos. Como un diseñador que utilizar VTL, usted y sus ingenieros
    deben llegar a un acuerdo respecto a los nombres de las referencias
    para que usted pueda utilizarlas correctamente en sus plantillas.
 </p>

 <p>
    Todo lo que entra y sale de una referencia se trata como una cadena
    de caracteres (un objeto String). Si existe un objeto que representa
    <em>$foo</em> (por ejemplo, un objeto Integer), entonces Velocity
    llamará el método <code>.toString()</code> de ese objeto para
    convertirlo en una cadena de caracteres.
 </p>

 <p>
 <a name="Variables"><strong>Variables</strong></a>
 <br />
    La notación breve de una variable esta compuesta por un signo "$"
    inicial seguido de un <em>Identificador</em>. Un identificador VTL
    debe comenzar con un caracter alfabético (a .. z ó A .. Z). El resto
    de los caracteres deb ser de alguno de los siguiente tipos:
 </p>

 <p>
   <ul>
     <li>alfabético (a .. z, A .. Z)</li>
     <li>numérico (0 .. 9)</li>
     <li>línea ("-")</li>
     <li>underscore ("_")</li>
   </ul>
 </p>

 <p>
    A continuación hay algunos ejemplos de referencias válidas en VTL:
 </p>

<source><![CDATA[
$foo
$lanzaLodo
$lanza-lodo
$lanza_lodo
$lanzaLodo1
]]></source>

<p>
    Cuando VTL hace referencia una variable, po ejemplo, <em>$foo</em>,
    la variable puede obtener su valor de una directiva <em>set</em>
    dentro de la plantilla, o del código Java. Por ejemplo, si la
    variable de Java <em>$foo</em> tiene el valor <em>bar</em> en el
    momento en que se solicita la plantilla, entonces <em>bar</em>
    reemplaza todas las ocurrencias (o instancias) de <em>$foo</em>
    dentro de la página web. De manera alterna, si se incluye el
    enunciado
 </p>

<source><![CDATA[
#set( $foo = "bar" )
]]></source>

<p>
    La salida será la misma para todas las instancias de <em>$foo</em>
    que se encuentren a continuación es esta directiva.
 </p>

 <p>
 <a name="Propiedades"><strong>Propiedades</strong></a>
 <br />
    El segundo sabor de referencias VTL son las propiedades; las
    propiedades tienen un formato particular. La versión corta se
    compone de un signo <em>$</em> seguido de un identificador VTL,
    seguido de un punto y de otro identificador VTL. A continuación hay
    ejemplos de referencias de propiedades válidas en VTL:
 </p>

<source><![CDATA[
$cliente.Direccion
$compra.Total
]]></source>

<p>
    Tome el primer ejemplo, <em>$cliente.Direccion</em>. Puede tener dos
    significados. Puede significar, Busque en la tabla de hashing
    identificada como <em>cliente</em> y devuelva el valor asociado con
    la llave <em>Direccion</em>. Pero <em>$customer.Address</em> puede
    también referirse a un método (las referencias que se relacionan con
    métodos se discutirán en la sección siguiente);
    <em>$customer.Address</em> puede ser una manera corta de escribir
    <em>$customer.getAddress()</em>. Cuando su página sea solicitada
    Velocity determinará cuál de las dos posibilidades tiene sentido, y
    luego devolverá el valor apropiado.
 </p>

 <p>
 <a name="Métodos"><strong>Methods</strong></a>
 <br />
    Un método esta definido dentro del código de Java y es capaz de
    hacer algo útil, como desarrollar un cálculo o llegar a una
    decisión. Los métodos son referencias compuestas de un signo "$"
    inicial seguido en un identificador VTL, seguido de un <em>Cuerpo de
        Método</em> VTL. Un cuerpo de método VTL, a su vez esta formado
    por un identificador VTL seguido por un paréntesis izquierdo ("("),
    seguido, opcionalmente, por una lista de parámetros, para terminar
    en un paréntesis derecho. A continuación hay ejemplos de referencias
    de métodos válidas dentro de VTL:

 </p>

<source><![CDATA[
$cliente.getDireccion()
$compra.getTotal()
$pagina.setTitulo( "My Página Principal" )
$persona.establecerAtributos( ["Extraño", "Raro", "Excitado"] )
]]></source>

<p>
    Los primeros dos ejemplos -- <em>$cliente.getDireccion()</em> y
    <em>$compra.getTotal()</em> -- pueden parecer similares a aquellos
    utilizados en la sección de propiedades, <em>$cliente.Direccion</em>
    y <em>$compra.Total</em>. Si usted supuso que estos ejemplos están
    relacionados de alguna manera, usted esta en lo cierto.
 </p>

 <p>
    Las Propiedades VTL pueden utilizarse como notación abreviada para
    los métodos de VTL. La propiedad <em>$cliente.Direccion</em> tiene
    exactamente el mismo efecto que el método
    <em>$cliente.getDireccion()</em> (Nótese el uso de la palabra
    inglesa <em>get</em> en lugar de la castellana <em>obtener</em>).
    Generalmente es preferible utilizar una Propiedad si esta
    disponible. La diferencia principal entre las propiedades y los
    métodos es que usted le puede dar una lista de parámetros a un
    Método.
 </p>

 <p>
 La notación breve se puede utilizar en los Métodos siguientes:
 </p>

<source><![CDATA[
$sol.getPlanetas()
$anhelido.getMugre()
$album.getFoto()
]]></source>

<p>
    Podríamos esperar que estos métodos devolvieran los nombres de los
    planetas que giran alrededor del sol, alimentaran un gusano de
    tierra y extrajeran una foro de un album. Los siguientes Métodos
    solo se pueden referenciar por medio de la notación larga:
 </p>

<source><![CDATA[
$sol.getPlaneta( ["Tierra", "Marte", "Neptuno"] )
## No es posible pasar una lista de parámetros con $sun.Planets

$sisifo.empujarPiedra()
## Si dijera $sisifo.piedra Velocity asumiría $sisifo.pushPiedra()

$libro.setTitulo( "Homenaje a Colombia" )
## No se puede pasar un parámetro en la notación abreviada.
]]></source>

 <p>
 <a name="NotaciónFormaldeReferencias"><strong>Notación Formal de
         Referncias</strong></a>
 <br />
 La notación abreviada para referencias fue utilizada en los ejemplos
 anteriores, pero también existe una notación formal para referencias,
 que se demuestra a continuación:
 </p>

<source><![CDATA[
${lanzaLodo}
${cliente.Direccion}
${compra.getTotal()}
]]></source>

<p>
Casi en todos los casos usted utilizará la notación abreviada, pero
existen escenarios en los cuales la notación formal se requiere para
procesar corectamente la plantilla.
 </p>

 <p>
 Suponga que usted estuviera creando una frase en la que <em>$vicio</em>
 se utilizará como prefijo para el ajetivo de una clase. La idea es
 permitir a alguién escoger la palabra base para producir uno de los dos
 siguientes resultados: "Juan es un pirómano." ó "Juan es un
 cleptómano.". En este caso la notación abreviada no es apropiada;
 considere el siguiente ejemplo:
 </p>

<source><![CDATA[
Juan is a $viciomano.
]]></source>

<p>
Hay ambigüedad aquí, y Velocity asume que <em>$viciomano</em>, no
<em>$vicio</em>, es el Identificador que usted quería utilizar. Al no
encontrar ningún valor para <em>$viciomano</em> Velocity escribirá
simplemente <em>$viciomano</em>. Este problema se resueklve usando
notación formal.
 </p>

<source><![CDATA[
Juan es un ${vicio}mano.
]]></source>

<p>
    Ahora Velocity save que la referencia es <em>$vicio</em> y no
    <em>$viciomano</em>. La notación formal es útil cuando las
    referencias están ubicadas directamente al lado del texto dentro de
    una plantilla.
 </p>


 <p>
 <a name="NotaciónSileciosadeReferencias"><strong>Notación de Referenias
         Silenciosas</strong></a>
 <br />
    Cuando Velocity encuentra una referencia indefinida, su
    comportamiento normal es es de escribir el nombre de la referencia.
    Por ejemplo, suponga que la siguiente referencia aparece como parte
    de una plantilla VTL.
 </p>

<source><![CDATA[
<input type="text" name="correo" value="$correo"/>
]]></source>

    <p>
    Cuando el formulario se carga por primera vez la referencia
    <em>$correo</em> no tiene valor, pero usted probablemente preferiría
    un texto en blanco a uno con el valor de "$correo". Usando la
    notación de referencias silenciosa se pasa por alto el
    comportamiento normal de Velocity. Para lograr eso en lugar de
    <em>$correo</em> en el VTL usted utilizaría <em>$!correo</em>. Con
    esta modificación el ejemplo anterior quedaría así:
 </p>

<source><![CDATA[
<input type="text" name="correo" value="$!correo"/>
]]></source>

<p>
    Ahora cuando el formulario se carga por primera vez y $correo no
    tenga valor una cadena vacía se escribirá en lugar de "$correo".
 </p>

 <p>
    La notación formal y la silenciosa se puede usar juntas como se
    muestra en el ejemplo siguiente:
 </p>

<source><![CDATA[
<input type="text" name="correo" value="$!{correo}"/>
]]></source>

</section>

<section name="Literalmente" href="Literalmente">

  <p>
  VTL hace uso de caracteres especiales, como <em>$</em> y <em>#</em>,
  para hacer su trabajo por lo que se debe tener algo de cuidado en el
  momento de utilizar estos caracteres dentro de las plantillas. Esta
  sección habla de como escapar el caracter <em>$</em>.
  </p>

  <p>
    <a name="Dinero"><strong>Dinero</strong></a>
    <br />
    No hay ningún problema en escribir "Yo compré un saco de maíz de
    2 kg. en el mercado de lagranja por sólo $2.50!". Como se mencionó
    anteriormente, un identificador VTL siempre comienza con una letra
    mayúscula o minúscula por lo que $2.50 no se confunde con una
    referencia.
  </p>

  <p>
  <a name="EscapandoReferenciasVTLVálidas"><strong>Escapando Referencias
          VTL Válidas</strong></a>
  <br />
  Pueden existir casos en donde haya la posibilidad de que Velocity se
  confunda. <em>Escapar</em> caracteres especiales es la mejor manera de
  manejar los caracteres partículares de VTL dentro de sus plantillas, y
  esto se puede hacer utilizando el caracter palote o backslash (
  <em>\</em> ).
  </p>

<source><![CDATA[
#set( $correo = "foo" )
$correo
]]></source>

<p>
    Si Velocity encuentra una referencia en su plantilla VTL a
    <em>$correo</em>, el buscará el contexto ppor un valor
    correspondiente. En este caso el resultado será <em>foo</em> por
    qué <em>$correo</em> esta definido. Si <em>$correo</em> no esta
    definido el resultado será <em>$correo</em>.
  </p>

  <p>
    Suponga que <em>$correo</em> está definido (por ejemplo, que tiene
    el valor <em>foo</em>) y que usted desea escribir <em>$correo</em>.
    Existen varias maneras de hacer esto pero la más sencilla es usar el
    caracter de escape.
  </p>

<source><![CDATA[
## La siguiente línea define $correo en esta plantilla:
#set( $correo = "foo" )
$correo
\$correo
\\$correo
\\\$correo
]]></source>

  <p>
     se muestra como
  </p>

<source><![CDATA[
foo
$correo
\foo
\$correo
]]></source>

  <p>
  Note que el caracter <em>\</em> se asocia con <em>$</em> por la
  izquierda. La regla de asociación por la izquierda hace que
  <em>\\\$correo</em> se muestre como <em>\\$correo</em>. Compare estos
  ejemplos con lo siguientes, en los que <em>$correo</em> no esta
  definido.
  </p>

<source><![CDATA[
$correo
\$correo
\\$correo
\\\$correo
]]></source>

  <p>
  se muestra como
  </p>

<source><![CDATA[
$correo
\$correo
\\$correo
\\\$correo
]]></source>

<p>
    Note que Velocity maneja de manera diferentes las referencias que
    están definidas de aquellas que no lo están. A continuación se
    encuentra una directiva que da a <em>$foo</em> el valor
    <em>verde</em>.
  </p>

<source><![CDATA[
#set( $foo = "verde" )
$luna = $foo
]]></source>

<p>
La salida será: <em>$luna = verde</em> -- donde <em>$luna</em> se
escribe literalmente porqué esta indefinido y <em>verde</em> se escribe
en lugar de <em>$foo</em>
  </p>


  <p>
    También es posible escapar directivas de VTL; esto se describe con
    más detalle en la sección de Directivas.
  </p>

</section>

<section name="Sustitución de Mayúsculas y Minúsculas" href="SustitucióndeMayúsculasyMinúsculas">

<p>
Ahora que usted esta familiarizado con las referencias, puede comenzar a
aplicarlas de manera efectiva en sus plantillas. Las referencias de
Velocity aprovechan algunos principios de Java que los diseñadores de
plantillas encontraránm fáciles de utilizar. Por ejemplo:
    </p>

<source><![CDATA[
$foo

$foo.getBar()
## el lo mismo que
$foo.Bar

$data.setUser("jon")
## es lo mismo que
#set( $data.User = "jon" )

$data.getRequest().getServerName()
## es lo mismo que
$data.Request.ServerName
## que a su vez, es igual a
${data.Request.ServerName}
]]></source>

<p>
Estos ejemplos ilustran usos alternativos para la mismas referencias.
Velocity se aprovechas de la instrospección y las capacidades de beans
de Java para resolver los nombre de referencias tanto en el Contexto
como en los métodos de los objetos. Es posible incluir y evaluar
referencias casi en cualquier lugar de su plantilla.
    </p>

    <p>
    Velocity, que ha sido modelado con las especificaciones de Bean
    definidas por Sun Microsystems, distingue entre mayúsculas y
    minúsculas; sin embargo sus desarrolladores se han esforzado para
    encontrar y corregir los errores del usuario cuando sea posible.
    Cuando el método <em>getFoo()</em> es referenciado dentro de una
    plantilla como <code>$bar.foo</code>, Velocity intentará primero
    <code>getfoo()</code>. Si esto falla, intentará <code>getFoo()</code>.
    De la misma manera, cuando una plantilla se refiera a
    <code>$bar.Foo</code>, Velocity intentará <em>$getFoo()</em> primero
    y luego <em>getfoo()</em>.
    </p>

    <p>
    Nota: <em>Las Referencias a variables de instancia dentro de una
        plantilla no se resuelven.</em> Solo las referencias a los
    atributos get y set de los JavaBeans se resuelven (i.e.
    <code>$foo.Nombre</code> se resuelve como el método de instancia
    <code>getNombre()</code> de la clase Foo, pero no como su variable
    de instancia <code>Nombre</code>).
    </p>

</section>


<section name="Directivas" href="Directivas">

<p>
    Las Referencias le permiten a los diseñadores de plantillas generar
    contenido dinámico para sitios web, mientras que las
    <em>directivas</em> -- elementos de script fáciles de usar que se
    pueden usar para manipular de manera creativa la salida del código
    Java -- les permiten a los diseñadores realmente estar a cargo de la
    apariencia y en contenido del sitio web.
 </p>

 <a name="Set"><strong>#set</strong></a>
 <p>
 La directiva <em>#set</em> se utiliza para establecer el valor de una
 referencia. El valor se puede asignar a una referencia de variable o
 una referencia de propiedad, siempre entre paréntesis, como se muestra
 a continuación:
 </p>

<source><![CDATA[
#set( $primate = "mono" )
#set( $cliente.Comportamiento = $primate )
]]></source>

<p>
    El lado izquierdo (LI) de la asignación debe ser una referencia de
    variable o una referencia de propiedad. El lado derecho (LD) puede
    ser de alguno de los siguientes tipos:
 </p>

 <p>
    <ul>
        <li>Referencia de Variable</li>
        <li>Constante de Cadena</li>
        <li>Referencia de Propiedad</li>
        <li>Referencia de Método</li>
        <li>Literal Numérico</li>
        <li>Lista de elementos como arreglo</li>
    </ul>
 </p>

 <p>
    These examples demonstrate each of the aforementioned types:
 </p>

<source><![CDATA[
#set( $mono = $pedro ) ## Referencia de Variable
#set( $mono.Amigo = "monica" ) ## Constante de Cadena
#set( $mono.Culpar = $casablanca.Fuga ) ## referencia de propiedad
#set( $mono.Plan = $doctor.llamar($web) ) ## referencia de método
#set( $mono.Numero = 123 ) ##Literal Numérico
#set( $mono.Decir = ["No", "es", $mi, "culpa"] ) ##Arreglo
]]></source>

 <p>
 NOTA: En el último ejemplo los elementos definidos con el operador
 [..] son accesibles usando los métodos definidos en la clase ArrayList.
 Así, por ejemplo, usted podría acceder el primer elemento del arreglo utilizando $mono.Decir.get(0), con lo que obtendría la palabra "No".
 </p>


 <p>
 El lado derecho también puede ser una expresión aritmética sencilla:
 </p>

<source><![CDATA[
#set( $value = $foo + 1 )
#set( $value = $bar - 1 )
#set( $value = $foo * $bar )
#set( $value = $foo / $bar )
]]></source>

<p>
    Si el Lado Derecho es una propiedad o referencia de método que se
    evalúa como <em>null</em>, <b>no</b> será asignada al lado
    izquierdo. No es posible remover una referencia existente del
    contexto utilizando este mecanismo. Esto puede ser confuso para los
    recién llegados a Velocity. Por ejemplo:
 </p>

<source><![CDATA[
#set( $resultado = $consulta.criterio("nombre") )
El resultado de la primera consulta en $resultado

#set( $resultado = $consulta.criterio("direccion") )
El resultado de la segunda consulta es $resultado
]]></source>

<p>
    Si <em>$consulta.criterio("nombre")</em> retorna la cadena "pedro",
    y <em>$consulta.criterio("direccion")</em> retorna <em>null</em>, el
    VTL anterio se mostraría de la siguiente manera:
 </p>

<source><![CDATA[
El resultado de la primera consulta en pedro

El resultado de la primera consulta en pedro
]]></source>

<p>
    Esto tiende a confundir a quines están comenzando, que construyen
    ciclos <em>#foreach</em> que intentan hacer <em>#set</em> de una
    referencia por medio de una propiedad o un método e inmediatamente
    evalúan la referencia con una directiva <em>#if</em>. Por ejemplo:
 </p>

<source><![CDATA[

#set( $criterios = ["nombre", "direccion"] )

#foreach( $criterio in $criterios )

    #set( $resultado = $consulta.criterios($criterio) )

    #if( $result )
    La consulta tuvo éxito
    #end

#end
]]></source>

<p>
    En el ejemplo anterior, no sería inteligente confiar en la
    evaluación de <em>$resultado</em> para determinar si una consulta
    tuvo éxito. Después de que <em>$result</em> ha sido agregado al
    contexto (por medio de una directiva <em>#set</em>), no puede volver
    a establecerse a <em>null</em> (quitarse del contexto). Los detalles
    de las directivas <em>#if</em> y <em>#foreach</em> son cubiertos con
    mayor detalle posteriormente en esta guía.
 </p>

 <p>
    Una solución para este problema puede ser predefinir
    <em>$resultado</em> a <em>false</em>. Luego, si la llamada a
    <em>$consulta.criterios()</em> falla, es posible verificar.
 </p>


<source><![CDATA[

#set( $criterios = ["nombre", "direccion"] )

#foreach( $criterio in $criterios )

    #set( $resultado = false )
    #set( $resultado = $consulta.criterios($criterio) )

    #if( $resultado )
        La consulta tuvo éxito
    #end

#end
]]></source>

<p>
    A diferencia de algunas de las otras directivas de Velocity, la
    directiva <em>#set</em> no tiene un enunciado <em>#end</em>.
 </p>

 <a name="CadenasdeCaracteres"><strong>Cadenas de Caracteres</strong></a>

 <p>
    Cuando se utiliza la directiva <em>#set</em>, los literales de
    cadena que están encerrados en comillas dobles serán evaluados y
    mostrados en la plantilla, como se demuestra a continuación:
 </p>

<source><![CDATA[
#set( $directorioRaiz = "www" )
#set( $nombrePlantilla = "indice.vm" )
#set( $plantilla = "$directorioRaiz/$nombrePlantilla" )
$plantilla
]]></source>

 <p>
 La salida será:
 </p>

<source><![CDATA[
www/indice.vm
]]></source>

<p>
    Sin embargo, cuando la cadena de caracteres esta encerrada en
    comillas sencillas, no será evaluada:
 </p>

<source><![CDATA[
#set( $foo = "bar" )
$foo
#set( $blarg = '$foo' )
$blarg
]]></source>

<p>Se muestra como:</p>

<source><![CDATA[
  bar
  $foo
]]></source>

<p>
    Por defecto, la característica de las comillas sencillas para
    mostrar texto sin evaluar esta disponible en Velocity; sin embargo
    este valor por defecto se puede cambiar editando el archivo
    <code>velocity.properties</code> de tal manera que
    <code>stringliterals.interpolate=false</code>.
 </p>
</section>


<section name="Sentencias If-Else" href="SentenciasIf-Else">

<strong>Condicionales</strong>
<p>
    La directiva <em>#if</em> en Velocity permite que se incluya texto
    dentro de la plantilla generada, con la condición de que el
    enunciado condicional evalue a verdadero. Por ejemplo:
</p>

<source><![CDATA[
#if( $foo )
   <strong>Velocity!</strong>
#end
]]></source>

<p>
    La variable <em>$foo</em> se evalúa para determinar si es verdadera,
    cosa que ocurrirá bajo una de dos circunstancias: (i) <em>$foo</em>
    es un valor booleano (verdadero ó falso) que tiene un valor de
    verdadero, ó (ii) el valor no es <em>null</em>. Recuerde que el
    contexto de Velocity solamente contiene objetos, por lo que cuando
    se dice 'booleano' se habla en realidad de la clase Boolean. Esto es
    cierto incluso para los métodos que devuelven un valor de tipo
    <code>boolean</code> - la infraestructura de introspección devolverá
    un <code>Boolean</code> del mismo valor lógico.
</p>

<p>
    El contenido que se encuentra entre el enunciado <em>#if</em> y el
    enunciado <em>#end</em> es lo que se escribe en la plantilla si la
    evaluación resulta en un valor verdadero. En este caso, si
    <em>$foo</em> es verdadero, la salida será: "Velocity!". De manera
    análoga, si <em>$foo</em> tiene un valor <em>null</em>, o evalua a
    falso, entonces el enunciado completo es falso y no se escribe nada.
</p>

<p>
    Un elemento <em>#elseif</em> ó <em>#else</em> puede utilizarse junto
    con una sentencia <em>#if</em> para indicar condiciones adicionales
    o la labor por defecto. Note que el Motor de Plantillas de Velocity
    parará en la primera expresión que evalue a verdadero. En el ejemplo
    siguiente suponga que <em>$foo</em> tiene un valor de 15 y
    <em>$bar</em> tiene un valor de 6.
</p>

<source><![CDATA[
#if( $foo < 10 )
    <strong>Vaya hacía el Norte</strong>
#elseif( $foo == 10 )
    <strong>Vaya hacía el Este</strong>
#elseif( $bar == 6 )
    <strong>Vaya al Sur</strong>
#else
    <strong>Vaya al Oeste</strong>
#end
]]></source>

    <p>En este ejemplo, <em>$foo</em> es mayor que diez, por lo que las
    dos primeras comparaciones fallan. A continuación se compara
    <em>$bar</em> con 6, como son iguales, la salida es <strong>Vaya al
        Sur</strong>
    </p>

    <p>
    <a name="OperadoresLógicosyRelacionales"><strong>Operadores
            Lógicos y Relacionales</strong></a>
    </p>

    <p>
    Velocity usa el operador de equivalencia para determinar las
    relaciones entre las variables. A continuación hay un ejemplo
    sencillo para ilustrar como se utiliza el operador de igualdad.
    </p>

<source><![CDATA[
#set ($foo = "ácido desoxiribonucleico")
#set ($bar = "ácido ribonucleico")

#if ($foo == $bar)
    En este caso es claro que no son equivalentes por lo que....
  In this case it's clear they aren't equivalent. So...
#else
    No son equivalentes y esta será la salida.
#end
]]></source>

<p>
    Velocity tiene también operadores lógicos para el Y, el O y el NO
    (AND, OR y NOT). Para mayor información vea la <a
        href="../vtl-reference-guide.html">Guía de Referencia VTL</a>.
    A continuación se encuentran ejemplos que demuestran la utilización
    de los operadores lógicos AND, OR y NOT.
    </p>

<source><![CDATA[

## Y lógico

#if( $foo && $bar )
    <strong>Esto Y aquello</strong>
#end

]]></source>

    <p>
    La directiva <em>#if()</em> solamente evaluará a verdadero si tanto
    <em>$foo</em> como <em>$bar</em> son ciertos. Si <em>$foo</em> es
    falso la expresión evaluará a falso; <em>$bar</em> no será evaluada.
    Si <em>$foo</em> es verdadero el Motor de Plantillas de Velocity
    verificará el valor de <em>$bar</em>; si <em>$bar</em> es cierto,
    entonces toda la expresión es cierto y la salida es <strong>Esto Y
        aquello</strong>. Si <em>$bar</em> es falso, entonces no habrá
    ninguna salida porque toda la expresión es falsa.
    </p>

    <p>
    El O lógico trabaja de la misma manera, pero sólo una de las
    referencias debe evaluar a verdadero para que toda la expresión
    evalue a verdadero. Considere el ejemplo siguiente.
    </p>

<source><![CDATA[

## O lógico

#if( $foo || $bar )
    <strong>Esto O Aquello</strong>
#end
]]></source>

    <p>
    Si <em>$foo</em> es verdadero, el Motor de Plantillas de Velocity no
    necesita consultar <em>$bar,</em>; sin importar si <em>$bar</em> es
    cierto o falso, la expresión será cierta, y <strong>Esto O
        Aquello</strong> será la salida. Si <em>$foo</em> es falso, en
    cambio, es necesario verificar <em>$bar</em>. En este caso, si
    <em>$bar</em> es falso, entonces la expresión es falsa y no se
    escribe nada. De otro lado, si <em>$bar</em> es verdadero, entonces
    toda la expresión es verdadera y el resultado es <strong>Esto O
        Aquello</strong>
    </p>

    <p>
    Con el operador lógico NO, solo hay un argumento :
    </p>

<source><![CDATA[

## NO lógico

#if( !$foo )
<strong>eso NO</strong>
#end

]]></source>

<p>
    Aquí si <em>$foo</em> es cierto, entonces <em>!$foo</em> es falso, y
    no se escribe nada. Por el contrario, si <em>$foo</em> es falso,
    entonces <em>!$foo</em> será verdadero y <strong>eso NO</strong>
    será escrito. Tenga cuidado de no confundir este operador con la
    <em>referencia sileciosa $!foo</em>, que es algo completamente
    distinto.
    </p>


 </section>

<section name="Ciclos Foreach" href="CiclosForeach">

   <strong>Ciclo Foreach</strong>

   <p>
    El elemento <em>#foreach</em> permite la construcción de ciclos. Por
    ejemplo:
    </p>

<source><![CDATA[
<ul>
#foreach( $producto in $todosProductos )
    <li>$producto</li>
#end
</ul>
]]></source>

<p>
    Este cilco <em>#foreach</em> hace que el objeto correspondiente a la
    lista de $todosProductos sea iterado buscando todos los productos de
    la lista. En cada iteración del ciclo, el valor de
    <em>$todosProductos</em> se asigna a la variable <em>$producto</em>.
    </p>

    <p>
    El contenido de la variable <em>$todosProductos</em> es un Vector,
    una tabla de Hashing (Hashtable) o un arreglo (Array). El valor
    asignado a la variable <em>$producto</em> es un objeto Java y se
    puede referenciar desde una variabkle como tal. Por ejemplo, si
    <em>$product</em> fuera realmente un elemento de la clase Producto
    en Java, su nombre se podría obtener referenciando el método
    <em>$producto.Nombre</em> (ie: <em>$Product.getName()</em>).
    </p>

    <p>
    Ahora supongamos que <em>$todosProductos</em> es una tabla de
    Hashing. Si usted quisiera recuperar los valores de las llaves de la
    tabla de Hashing, al igual que los objetos dentro de esta, usted
    podría utilizar código como el siguiente:
    </p>

<source><![CDATA[
<ul>
    #foreach( $llave in $todosProductos.keySet() )
    <li>Llave: $llave -> Valor: $todosProductos.get($llave)</li>
#end
</ul>
]]></source>

<p>
    Velocity proporciona una manera sencilla de obtener el contador del
    ciclo para que usted pueda hacer algo como lo siguiente:
</p>

<source><![CDATA[
<table>
    #foreach( $cliente in $listaClientes )
    <tr><td>$foreach.count</td><td>$cliente.Nombre</td></tr>
#end
</table>
]]></source>

 </section>

<section name="Include" href="Include">

    <p>
    El elemento de script <em>#include</em> le permite al diseñador de
    plantillas importar un archivo local, que después es insertado en la
    localización donde se encuentra la sentencia <em>#include</em>. Los
    contenidos del archivo no se muestran por intermedio del motor de
    plantillas por lo que si se hacen referencias dentro del archivo,
    estas no serán reemplazadas. Por motivos de seguridad el archivo que
    va a ser incluido debe encontrarse en el directorio indicado por la
    propiedad TEMPLATE_ROOT.
    </p>

<source><![CDATA[
#include( "uno.txt" )
]]></source>

<p>
    El archivo al que se refiere la directiva <em>#include</em> se
    encierra entre comillas. Si mas de un archivo será incluido, los
    nombres de los archivos a incluir deben ir separados por comas.
    </p>

<source><![CDATA[
#include( "uno.gif","dos.txt","tres.htm" )
]]></source>

<p>
    El archivo a incluir no tiene que ser referenciado por nombre, de
    hecho, muchas veces es preferible usar una variable, en lugar de un
    nombre de archivo. Esto puede ser útil para dirigir la salida de
    acuerdo a criterios determinados cuando la solicitud de la página es
    enviada, es decir, que dependa de factores como los datos del
    usuario que visita la página, el momento del día, etc. A
    continuación se muestra un ejemplo en el que se usan tanto un nombre
    como una variable.
    </p>

<source><![CDATA[
#include( "greetings.txt", $seasonalstock )
]]></source>

 </section>

<section name="Parse" href="Parse">

<p>
    El elemento de script <em>#parse</em> le permite al diseñadore de
    plantillas importar un archivo local que contiene VTL. Velocity
    procesará el VTL y mostrará la plantilla especificada.
</p>

<source><![CDATA[
#parse( "yo.vm" )
]]></source>

<p>
    Al igual que la directiva <em>#include</em>, <em>#parse</em> puede
    utilizar una variable, en lugar de una plantilla. Todas las
    plantillas a las que <em>#parse</em> se refiera deben incluirse bajo
    TEMPLATE_ROOT. A diferencia de la directva <em>#include</em>,
    <em>#parse</em> solo recibe un argumento.
</p>

<p>
    Las plantillas de VTL puede tener sentencias <em>#parse</em> que se
    refieran a plantillas que a su vez tengan sentencias
    <em>#parse</em>. La línea <em>parse_directive.maxdepth</em> del
    archivo <code>velocity.properties</code>, cuyo valor por defecto es
    10, permite a los usuarios configurar el máximo número de
    referencias a <em>#parse</em> que pueden ocurrir desde una única
    plantilla. (Nota: Si la propiedad <em>parse_directive.maxdepth</em>
    no esta dentro del archivo <code>velocity.properties</code>,
    Velocity establecerá el valor por defecto en 10.) La recursión esta
    permitida, por ejemplo, si la plantilla <code>hacerfoo.vm</code>
    contiene las siguientes líneas:
    </p>

<source><![CDATA[
Cuenta Regresiva.
#set( $cuenta = 8 )
#parse( "parsefoo.vm" )
Listo hacerfoo.vm!
]]></source>

<p>
    Hay una referencia a la plantilla <code>parsefoo.vm</code>, que
    contiene el siguiente código VTL:
</p>

<source><![CDATA[
$cuenta
#set( $cuenta = $cuenta - 1 )
#if( $cuenta > 0 )
    #parse( "parsefoo.vm" )
#else
    Listo parsefoo.vm!
#end
]]></source>

<p>
    Después de que se muestra "Cuenta Regresiva.", Velocity pasa por
    <code>parsefoo.vm</code>, contando hacía abajo desde 8. Cuando el
    conteo llegue a 0, mostrará el mensaje "Listo parsefoo.vm!". En este
    punto Velocity volverá a <code>dofoo.vm</code> y escribirá el
    mensaje "Listo hacerfoo.vm!".
    </p>

 </section>


<section name="Stop" href="Stop">

<p>
El elemento de script <em>#stop</em> permite al diseñador parar la
ejecución del motor de plantillas y volver. Esto es útil para propósitos
de corrección de errores.
</p>

<source><![CDATA[
#stop
]]></source>
 </section>

<section name="Velocimacros" href="Velocimacros">

    <p>
    El elemento de script <em>#macro</em> script permite definir un
    segmento de plantilla VTL repetitivo. Los Velocimacros son muy
    útiles en una amplia gama se situaciones, tanto simples como
    complejas. El siguiente Velocimacro, creado con el único propósito
    de ahorrar tecleo y minimizar errores tipográficos, provee una
    introducción al concepto de Velocimacros
    element allows template designers to.
    </p>

<source><![CDATA[
#macro( d )
<tr><td></td></tr>
#end
]]></source>

<p>
    El Velocimacro que se define en este ejemplo es <em>d</em>, y se
    puede llamar de manera similar a cualquier otra directiva VTL:
    </p>

<source><![CDATA[
#d()
]]></source>

<p>
Cuando esta plantilla sea solicitada, Velocity reemplazará <em>#d()</em>
por una fila conteniendo un única celda vacia.
</p>

<p>
Un Velocimacro puiede tomar cualquier número de argumentos -- no tener
ningún argumento, como se mostró en el primer ejemplo, es una opción --
pero cuando sea invocado el Velocimacro debe ser llamado con el mismo
número de argumentos con el que fue definido. Muchos Velocimacros se
relacionan con el entorno mucho más con su entorno que el ejemplo
demostrado anteriormente. Aquí hay un Velocimacro que recibe dos
argumentos, un color y un arreglo.
</p>

<source><![CDATA[
#macro( filastabla $color $algunalista )
#foreach( $algo in $algunalista )
    <tr><td bgcolor=$color>$algo</td></tr>
#end
#end
]]></source>

<p>
El Velocimacro que se define en este ejemplo, <em>filastabla</em>, toma
dos argumentos. El primer argumento toma el lugar de <em>$color</em>, y
el segundo argumento el de <em>$algunalista</em>
    </p>

    <p>
Cualquier cosa que se pueda incluir dentro de una plantilla VTL puede
formar parte delcuerpo de un Velocimacro. El Velocimacro
<em>filastabla</em> es una sentencia <em>foreach</em>. Hay dos
sentencias <em>#end</em> dentro del Velocimacro; la primera pertenece al
<em>foreach</em> y a segunda termina la definición del Velocimacro.
    </p>

<source><![CDATA[
#set( $grandeslagos = ["Superior","Michigan","Huron","Erie","Ontario"] )
#set( $color = "blue" )
<table>
    #filastabla( $color $grandeslagos )
</table>
]]></source>

    <p>
    Note que <em>$grandeslagos</em> toma el lugar de
    <em>$algunalista</em>. Cuando el Velocimacro es llamado en esta
    situación, la siguiente salida es generada:
    </p>

<source><![CDATA[
<table>
    <tr><td bgcolor="blue">Superior</td></tr>
    <tr><td bgcolor="blue">Michigan</td></tr>
    <tr><td bgcolor="blue">Huron</td></tr>
    <tr><td bgcolor="blue">Erie</td></tr>
    <tr><td bgcolor="blue">Ontario</td></tr>
</table>
]]></source>

<p>
Los Velocimacro pueden ser definidos <em>inline</em> dentro de una
plantilla. Esto quiere decir que la definición del macro no esta
disponible para otras plantillas dentro del mimso sitio Web. Definir un
Velocimacro de tal forma que sea compartido por todas las plantillas
tiene ventajas obvias: Reduce la necesidad de redefinir el macro en
varias plantillas, ahorrando trabajo y disminuyendo las posiblidades de
error, además de asegurar que un único cambio en un archivo quedará
disponible para todas las plantillas.
</p>

<p>
Si el Velocimacro <em>#filastabla($color $lista)</em> fuera definido en
una librería, se podría utilizar en cualquiera de la plantillas
normales; se podría utilizar muchas veces con propósitos distintos. En
la plantilla <code>vegetal.vm</code> dedicado a todas las plantas, el
Velocimacro <em>#filastabla</em> podría invocarse para listar las partes
de un vegetal típico:
    </p>

<source><![CDATA[
#set( $partes = ["raíz","tallo","hojas","flores","frutos"] )
#set( $colorCelda = "#CC00FF" )
<table>
    #filastabla( $colorCelda $parts )
</table>
]]></source>

<p>
Cuando atendiera ls solicitud de <code>vegetal.vm</code>, Velocity
encontraría el macro <em>#filastabla</em> en la librería de plantillas
(definida en el archivo <code>velocity.properties</code>) y generaría el
siguiente resultado:
    </p>

<source><![CDATA[
<table>
    <tr><td bgcolor="#CC00FF">raíz</td></tr>
    <tr><td bgcolor="#CC00FF">tallo</td></tr>
    <tr><td bgcolor="#CC00FF">hojas</td></tr>
    <tr><td bgcolor="#CC00FF">flores</td></tr>
    <tr><td bgcolor="#CC00FF">frutos</td></tr>
</table>
]]></source>

<strong>Argumentos de un Velocimacro</strong>

<p>
Los Velocimacros pueden recibir como argumentos cualquiera de los
siguientes elementos de VTL:
  </p>

  <ul>
    <li>
    Referencia : cualquier cosa que comience con '$'
    </li>
    <li>
    Cadena de caracteres : algo como "$foo" u 'hola'
    </li>
    <li>
      Número : 1, 2 etc
    </li>
    <li>
        Rango de enteros : [ 1..2] ó [$foo .. $bar]
    </li>
    <li>
        ObjectArray : [ "a", "b", "c"]
    </li>
    <li>
       El valor booleano "verdadero"
    </li>
    <li>
       El valor booleano "falso"
    </li>
  </ul>

  <p>
    Cuando pase referencias como argumentos para los Velocimacros tenga
    en cuenta que las referencias se pasan 'por nombre'. Esto quiere
    decir que su valor es 'generado' cada vez que se usa dentro del
    Velocimacros. Esta característica le permite pasar referencias con
    las llamadas de método y hacer que el método se llame cada vez. Por
    ejemplo, cuando llame el siguiente Velocimacro
   </p>

   <source><![CDATA[
   #macro( llamame $a )
         $a $a $a
     #end

#llamame( $foo.bar() )
   ]]></source>

   <p>
    Esa llamada hace que el método bar() de la referencia $foo sea
    llamado 3 veces.
    </p>

    <p>
    A primera vista, esta característica parece sorprendente, pero
    cuando se tiene en cuenta la motivación original de los Velocimacros
    -- eliminar la duplicación de "copiar y pegar" del VTL usado varias
    veces -- tiene mucho sentido. Permite pasar al Velocimacro objetos
    con estado, como un objeto que genera colores en una secuencia
    repetitiva para colorear las filas de una tabla.
    </p>

    <p>
    Si usted no desea utilizar esta característica siempre es posible
    simplemente obtener el valor del método como una nueva referencia y
    pasar ese valor:
    </p>

    <source><![CDATA[
    #set( $mivalor = $foo.bar() )
    #llamame( $mivalor )
   ]]></source>


   <strong>Propiedades de un Velocimacro</strong>

   <p>
   Varias líneas en al archivo <code>velocity.properties</code> permiten
   flexibilizar la implementación de los Velocimacro. Tenga en cuenta
   que estas propiedades también están documentadas en la <a
       href="../developer-guide.html">Guía de Desarrolladores</a>.
   </p>

   <p>
   <code>velocimacro.library</code> - Una lista, separada por comas de
   todas la librerias de plantillas de Velocimacros. Por defecto,
   Velocity busca una sola librería: <em>VM_global_library.vm</em>. El
   directorio en el que se buscan las plantillas también se utiliza para
   localizar las librerías.
    </p>

    <p>
    <code>velocimacro.permissions.allow.inline</code> - Esta propiedad,
    que tiene como valores posibles verdadero y falso (true y false),
    determina si los Velocimacros pueden ser definidos dentro de las
    plantillas normales.
    El valor por defecto, verdadero, le permite a los diseñadores
    definir por si mismos macros en las plantillas.
    </p>

    <p>
    <code>velocimacro.permissions.allow.inline.to.replace.global</code> -
    Con valores posibles verdadero y falso (true y false), esta
    propiedad le permite al usuario decidir si un Velocimacro definido
    inline dentro de una plantilla puede reemplazar a la plantilla
    global, que fue cargada al comienzo por medio de la propiedad
    <code>velocimacro.library</code>. El valor por defecto, falso
    (<code>false</code>), evita que los Velocimacros definidos en una
    plantilla reemplacen a los que fueron cargados al inicio.
    </p>

   <p>
   <code>velocimacro.permissions.allow.inline.local.scope</code> -
    Con valores posibles verdadero y falso (true y false), valor por
    defecto falso, esta propiedad dice si los Velocimacros definidos
    inline son 'visibles' únicamente para la plantilla que los define.
    Usted puede usar esta característica para hacer algunos trucos de
    VM - si un VM global llama a otro VM global, con ancance inline, una
    plantilla puede definir una implementación privada del segundo VM,
    que será llamada por el primer VM cuando sea invocado en esa
    plantilla. Ninguna de las otras templates es afectada.
    </p>

    <p>
    <code>velocimacro.library.autoreload</code> - Esta propiedad
    controla el cargado automático de la libreria de Velocimacros. El
    valor por defecto es <code>false</code>. Cuando es verdadero
    (<code>true</code>) la librería fuente de un Velocimacro que ha sido
    invocado será verificada para comprobar que no haya cambiado, y si
    lo ha hecho será recargada. Esta característica le permite cambiar y
    probar librerías de macros sin necesidad de reiniciar la aplicación
    o el contenedor de servlets, de la misma manera que se hace con
    plantillas normales.
    Este modo solo funciona cuando el caché esta <i>apagado</i>
    en los cargadores de recursos( e.g. <code>file.resource.loader.cache
        = false</code>).
    Esta característica esta pensada para el proceso de desarrollo, no
    el de producción.
    This property
    </p>

    <strong>Cosas y Casos de Velocimacros</strong>

    <p>
    Actualmente los Velocimacros deben ser definidos antes de ser
    utilizados por primera vez dentro de una plantilla. Esto significa
    que sus declaraciones de #macro() deben aparecerantes de que usted
    utilice los Velocimacros.
    </p>

    <p>
    Esto es importante recordarlo cuando usted intenta hacerle #parse()
    a una plantilla que contiene directivas #macro(). Como el #parse()
    ocurre en tiempo de ejecución, y el parser decide si un elemento que
    parece una VM es realmente un VM cuando esta haciendo el #parse(),
    entonces probablemente el #parse() de un conjunto de declaraciones
    no funciona como se esperaría. Para evitar este problema,
    simplemente utilice la propiedad
    <code>velocimacro.library</code>para cargar todos sus VM cuando se
    inicie la aplicación.
    </p>
 </section>

<section name="Escapando Directivas VTL" href="EscapandoDirectivasVTL">
<p>
Las directivas de VTL se pueden escapar con el palote invertido o
backslash ("\") de manera similar a como se escapan las referencias de
VTL válidas.
</p>

<source><![CDATA[
## #include( "a.txt" ) se muestra como <contenidos of de a.txt>
#include( "a.txt" )

## \#include( "a.txt" ) se muestra como #include( "a.txt" )
\#include( "a.txt" )

## \\#include ( "a.txt" ) se muestra como \<contenidos de a.txt>
\\#include ( "a.txt" )
]]></source>

<p>
Se debe tener especial cuidado cuando se escapan directivas de VTL que
contienen varios elementos de script en una misma directiva (como en las
sentencias if-else-end). A continuación seencuentra un ejemplo de un
condicional típico de VTL:
  </p>

<source><![CDATA[
#if( $jazz )
    Vyacheslav Ganelin
#end
]]></source>

  <p>
  Si <em>$jazz</em> es cierto la salida es
  </p>
<source><![CDATA[
Vyacheslav Ganelin
]]></source>

  <p>
  Si <em>$jazz</em> es fals, no hay salida. Escapar elementos de script
  altera la salida. Considere el siguiente caso:
  </p>

<source><![CDATA[
\#if( $jazz )
    Vyacheslav Ganelin
\#end
]]></source>

<p>
Sin importar si <em>$jazz</em> es verdadero o falso, la salida será:
</p>

 <source><![CDATA[
 #if($ jazz )
     Vyacheslav Ganelin
 #end
 ]]></source>

 <p>
 De hecho, como todos los elementos de script están escapados,
 <em>$jazz</em> nunca se evalúa por su valor booleano.
 Suponga que los palotes invertidos preceden a elementos de script que
 están legitimamente escapados:
  </p>

<source><![CDATA[
\\#if( $jazz )
   Vyacheslav Ganelin
\\#end
]]></source>

<p>
En este caso, si <em>$jazz</em> es verdadero, la salida es
</p>

<source><![CDATA[
\ Vyacheslav Ganelin
\
]]></source>

<p>
Para entender esto tenga en cuenta que <code>#if( arg )</code>, cuando
es terminado por un caracter de fin de línea (retorno) omitirá ese
caracter de la salida. Por lo tanto, el cuerpo del bloque
<code>#if()</code> va a continuación del primer '\', que se generó a
partir del '\\' que precedía el <code>#if()</code> dentro de la
pantilla. El último \ está en una línea distinta que el texto porqué hay
un retorno después de 'Ganelin', por lo que el \\ final, que precede el
<code>#end</code> hace parte del cuerpo del bloque.
  </p>


  <p>
  Si <em>$jazz</em> es falso, la salida es
  </p>

<source><![CDATA[
\
]]></source>

  <p>
  Tenga en cuenta que las
  cosas dejan de funcionar si los elementos de script no son escapados
  de manera correcta.
  </p>

<source><![CDATA[
\\\#if( $jazz )
    Vyacheslave Ganelin
\\#end
]]></source>

  <p>
  Aquí el <em>#if</em> esta escapado, pero hay un <em>#end</em> que
  sobra; al haber demasiados cierres (end) sin sus correspondientes
  aperturas (foreach ó if) se generará un error de procesamiento.
  </p>

 </section>

<section name="VTL: Asuntos de Formato" href="VTL:AsuntosdeFormato">

<p>
A pesar de que el VTL mostrado en esta guía del usuario se muestra en la
mayoría de los casos con cambios de línea y espacios en blanco, el VTL
que se muestra a continuación
    </p>

<source><![CDATA[
#set( $imperial = ["Munetaka","Koreyasu","Hisakira","Morikune"] )
#foreach( $shogun in $imperial )
    $shogun
#end
]]></source>

<p>
es tan válido como el siguiente trozo de código que Geir Magnusson Jr.
publicó a la lista de correo de usuarios de Velocity para ilustrar un
punto sin ninguna relación:
</p>

<source><![CDATA[
Enviame #set($foo = ["$10 y ","un pastel"])#foreach($a in $foo)$a #end
por favor.
]]></source>

<p>
El comportamiento de Velocity es el de ingnorar el espacio vacío de
exceso. La directiva descrita anteriormente puede reescribirse como:
</p>

<source><![CDATA[
Enviame
#set( $foo = ["$10 y ","un pastel"] )
#foreach( $a in $foo )
$a
#end
por favor.
]]></source>

    <p>
    o como
    </p>

<source><![CDATA[
Enviame
#set($foo       = ["$10 y ","un pastel"])
                 #foreach           ($a in $foo )$a
    #end por favor.
]]></source>

<p>
En cada caso la salida será la misma
    </p>

</section>

<section name="Otras Características y Miscelánea" href="OtrasCaracterísticasyMiscelánea">

<subsection name="Matemáticas" href="Matemáticas">

<p>
Velocity tiene varias funciones matemáticas incluidas que pueden ser
utilizadas en plantillas con la directiva <em>set</em>. Las siguientes
ecuaciones son ejemplos de suma, resta, multiplicación y división
respectivamente:
</p>

<source><![CDATA[
#set( $foo = $bar + 3 )
#set( $foo = $bar - 4 )
#set( $foo = $bar * 6 )
#set( $foo = $bar / 2 )
]]></source>

<p>
  Cuando una operaci&#243;n de divisi&#243;n se realiza
  entre dos operandos enteros, el resultado ser&#225; un
  valor entero, correspondiente al valor truncado de la
  divisi&#243;n. El valor del resto puede obtenerse
  utilizando el operador m&#243;dulo (<em>%</em>).
</p>

<source><![CDATA[
#set( $foo = $bar % 5 )
]]></source>


  </subsection>

<subsection name="El Operador de Rango" href="ElOperadordeRango">

<p>
El operador de rango se puede usar en conjunción con las directivas
<em>#set</em> y <em>#foreach</em>. Es muy útil por su capacidad para
crear arreglos de objetos compuestos por enteros. La construcción del
operador rango es como sigue:
</p>

<source><![CDATA[
[n..m]
]]></source>

<p>
Tanto <em>n</em> como <em>m</em> debe ser o producir enteros. El hecho
de que <em>m</em> sea mayor o menor que <em>n</em> no importa; en ese
caso el rango cimplemente contará hacía abajo. A continuación se
muestran varios ejemplos de uso del operador rango:
</p>

<source><![CDATA[
Primer ejemplo:
#foreach( $foo in [1..5] )
$foo
#end

Segundo ejemplo:
#foreach( $bar in [2..-2] )
$bar
#end

Tercer ejemplo:
#set( $arr = [0..1] )
#foreach( $i in $arr )
$i
#end

Cuarto ejemplo:
[1..3]
]]></source>

  <p>
  Produce lo siguiente:
  </p>

  <source><![CDATA[
Primer ejemplo:
1 2 3 4 5

Segundo ejemplo:
2 1 0 -1 -2

Tercer ejemplo:
0 1

Cuarto ejemplo:
[1..3]
]]></source>

<p>
enga en cuenta que el operador de rango solamente produce un arreglo
cuando se utiliza junto con las directivas <em>#set</em> y
<em>#foreach</em>, como se demuestra en el cuarto ejemplo.
</p>

<p>
Los diseñadores de páginas preocupados con hacer los tamaños de las
tablas iguales, pero con información que puede no se suficiente para
llenar la tabla, encontrarán el operador de rango particularmente útil.
</p>

  </subsection>

<subsection name="Temas Avanzados: Escapando y !" href="TemasAvanzados:Escapandoy!">

<p>
Cuando una referencia se hace silenciona con el caracter <em>!</em> y el
caracter <em>!</em> viene precedido por un caracter de escape
<em>\</em> la referencia se maneja de una manera diferente. Observe las
diferencias entre el escape sencillo y el caso especial en el que
<em>\</em> precede a <em>!</em>:
</p>

<source><![CDATA[
#set( $foo = "bar" )
$\!foo
$\!{foo}
$\\!foo
$\\\!foo
]]></source>

  <p>
   Se muestra como:
  </p>

<source><![CDATA[
$!foo
$!{foo}
$\!foo
$\\!foo
]]></source>

  <p>
   A diferencia del escape normal, donde <em>\</em> precede a <em>$</em>:
  </p>

<source><![CDATA[
\$foo
\$!foo
\$!{foo}
\\$!{foo}
]]></source>

  <p>
  Se muestra como:
  </p>

<source><![CDATA[
$foo
$!foo
$!{foo}
\bar
]]></source>

 </subsection>

<subsection name="Miscelánea de Velocimacro" href="MisceláneadeVelocimacro">

<p>
Esta sección contiene un conjunto de preguntas frecuentes (FAQ)
relacionadas con Velocimacros. Esta sección cambiará con el tiempo, por
lo que es bueno revisar si hay información nueva de cuando en cuando.
</p>

<p>
Nota : A través de esta sección 'Velocimacro' será abreviado como 'VM'.
</p>

<strong>¿Puedo usar una directiva u otro VM como argumento para un VM?</strong>

<p>
Ejemplo : <code>#center( #bold("hola") )</code>
</p>

<p>
No.  Una directiva no es un argumento válido para una directiva y, para
la mayoría de los propósitos prácticos, un VM es una directiva.
</p>

<p>
<i>Sin embargo...</i>, hay cosas que usted puede hacer. Una solución
sencilla es aprovechar el hecho de que la doble comilla (") muestra sus
contenidos, por lo que usted puede hacer algo como
</p>

<source><![CDATA[
#set($cosas = "#bold('hola')" )
#center( $cosas )
]]></source>

<p>
Puede tener un paso...
</p>

<source><![CDATA[
#center( "#bold( 'hola' )" )
]]></source>

<p>
Tenga en cuenta que en segundo ejemplo el argumentos es evaluado <i>
    dentro</i> de la VM, no a nivel del llamador. En otras palabras, el
argumento para el VM es pasado completo y evaluado dentro del VM al que
se le pasa. Esto le permite hacer cosas como :
</p>

<source><![CDATA[

#macro( interno $foo )
  interno : $foo
#end

#macro( externo $foo )
   #set($bar = "externolala")
   externo : $foo
#end

#set($bar = 'calltimelala')
#externo( "#interno($bar)" )

]]></source>

<p>
Donde la salida es
</p>

<source><![CDATA[
externo : interno : externolala
]]></source>

<p>
la evaluación de "#interno($bar)" se lleva a cabo dentro de #externo(),
por lo que el valor $bar establecido dentro de #externo() es el que se
utiliza.
</p>

<p>
Estas es una característica intencional y celosamente protegina - los
argumentos se pasan por nombre a los VM para que usted le pueda
'entregar' a los VMs referencias con estado como
</p>

<source><![CDATA[
#macro( foo $color )
  <tr bgcolor=$color><td>Hola</td></tr>
  <tr bgcolor=$color><td>Todos</td></tr>
#end

#foo( $bar.colorFila() )
]]></source>

<p>
Y lograr que colorFila() se llame varias veces, en lugar de solo una.
Par evitar que eso ocurra invoque el método fuera del VM y pásele el
valor al VM.
</p>

<source><![CDATA[
#set($color = $bar.colorFila())
#foo( $color )
]]></source>


<strong>¿Puedo registrar Velocimacros por medio de #parse() ? </strong>

<p>
Actualmente, los Velocimacros deben ser definidos antes de ser usados
por primera vez dentro de una plantilla. Esto significa que sus
declaraciones de #macro() deben venir antes de que usted use los
Velocimacros.
</p>

    <p>
    Esto es importante recordarlo cuando usted intenta hacerle #parse()
    a una plantilla que contiene directivas #macro(). Como el #parse()
    ocurre en tiempo de ejecución, y el parser decide si un elemento que
    parece una VM es realmente un VM cuando esta haciendo el #parse(),
    entonces probablemente el #parse() de un conjunto de declaraciones
    no funciona como se esperaría. Para evitar este problema,
    simplemente utilice la propiedad
    <code>velocimacro.library</code>para cargar todos sus VM cuando se
    inicie la aplicación.
    </p>


    <strong>¿Qué es la auto recarga de Velocimacros?</strong>

    <p>
    Existe una propiedad, pensada para usarse en <i>desarrollo</i>, no
    en producción :
  </p>

  <p>
  <code>velocimacro.library.autoreload</code>
  </p>

  <p>
  que tiene como valor por defecto falso. Cuando se hace verdadera
  <em>junto con</em> <code>&lt;tipo&gt;.resource.loader.cache = false</code>
  (where &lt;tipo&gt; es el nombre del cargador de recursos que usted
  esta utilizando, como 'file' para archivos) entonces el motor de
  Velocity recargará automáticamente los cambios en su librerías en el
  momento en que los haga para que usted no tenga que reinicar el motor
  de servlets o la aplicación, o hacer otros trucos para lograr que sus
  Velocimacros se recarguen.
    </p>

    <p>
    A continuación se muestra un conjunto sencillo de propiedades de
    configuración.
    </p>

    <source><![CDATA[
    file.resource.loader.path = templates
    file.resource.loader.cache = false
    velocimacro.library.autoreload = true
    ]]></source>

    <p>No utilice esto en producción</p>

</subsection>

<subsection name="Concatenación de Cadenas" href="ConcatenacióndeCadenas">

<p>
Una pregunta común que los desarrolladores formulan es <i>¿Cómo
    concateno cadenas de caracteres? ¿Existe algún análogo al operador
    '+' en Java?</i>
   </p>

   <p>
   Para concatenar referencias en VTL usted solo tiene que 'ponerlos
   juntos'. El contenido del contexto  en donde usted desee juntar las
   referencias es importante, por lo que ilustraremos con algunos
   ejemplos.
   </p>

   <p>
   En el código regular de una plantilla (cuando usted lo mezcla con
   contenido normal)
   </p>

   <source><![CDATA[
   #set( $tam = "Big" )
   #set( $nombre = "Ben" )

   El reloj es $tam$nombre.
   ]]></source>

   <p>
    y la salida será 'El reloj es BigBen'. Para caso más interesantes,
    como cuando ested desea concatenar las cadenas que pasará a un
    método, o establecer el valor de una nueva referencia use
   </p>

   <source><![CDATA[
      #set( $tam = "Big" )
      #set( $nombre = "Ben" )

      #set($reloj = "$tam$nombre" )

        El reloj es $reloj.
    ]]></source>

    <p>
    Que resultará en la mismo que el ejemplo anterior. Como un ejemplo
    final, cuando usted desea mezclar cadenas 'estáticas' con sus
    referencias usted puede necesitar 'referencias formales':
    </p>

    <source><![CDATA[
      #set( $tam = "Big" )
      #set( $nombre = "Ben" )

      #set($reloj = "${tam}Alto$nombre" )

      El reloj es $reloj.
    ]]></source>

    <p>
    Ahora el resultado es 'El reloj es BigAltoBen'. La notación formal
    es necesaria para que el procesador de las plantillas sepa que usted
    quiso usar la referencia '$tam', en lugar de '$tamAlto', que sería
    lo que entendería si los corchetes '{}' no estuvieran presentes.
    </p>
</subsection>

</section>

<section name="Retroalimentación" href="Retroalimentación">

<p>
Si encuentra algún error en este manual o tiene algún otro comentario o
retroalimentación relacionada con la guía del usuario de Velocity, por
favor envie un correo a <a
    href="mailto:user@velocity.apache.org">La lista de usuarios
    de Velocity</a>.
Gracias!
  </p>

</section>

</body>
</document>
